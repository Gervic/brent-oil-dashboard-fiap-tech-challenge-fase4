# -*- coding: utf-8 -*-
"""Model development

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KYtODkvjFOC03ZygXpViL4vXCyzrBoBw
"""

import pandas as pd
import numpy as np
import plotly.graph_objects as go
import plotly.express as px
from datetime import datetime, timedelta, date
from statsmodels.tsa.seasonal import seasonal_decompose
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
from statsmodels.tsa.arima.model import ARIMA
from sklearn.metrics import mean_squared_error
from statsmodels.tsa.stattools import adfuller
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf
from prophet import Prophet
from prophet.plot import plot_plotly, plot_components_plotly
from prophet.diagnostics import performance_metrics, cross_validation
from prophet.plot import plot_cross_validation_metric
import joblib
import warnings
import yfinance as yf

#!pip show joblib

def read_data():
    # Obter dados do Brent do yfinance
    ticker = "BZ=F"  # C√≥digo do Brent
    data = yf.download(ticker, start="2010-01-01", end=datetime.now().strftime("%Y-%m-%d"))
    # Diagn√≥stico
    if data.empty:
        st.error("‚ùå Falha ao carregar dados do Yahoo Finance")
        raw_data_link = 'https://raw.githubusercontent.com/Gervic/brent-oil-dashboard-fiap-tech-challenge-fase4/refs/heads/main/petrol_price_data.csv'
        raw_data = pd.read_csv(raw_data_link, sep=';')
        brent_data = raw_data[['Date', 'petrol_price']]
        brent_data['petrol_price'] = brent_data['petrol_price'].str.replace(',', '.').astype(float)
        st.info('Dados carregados da base hist√≥rica dispon√≠vel no Github')
        return brent_data
    else:
        return data

df_brent = read_data()

"""### Basic checks"""

df_brent.info()

df_brent.describe().T

df_brent['Date'] = pd.to_datetime(df_brent['Date'])
df_brent = df_brent.sort_values(by='Date')
df_brent = df_brent.set_index('Date')

fig = go.Figure()

# Pre√ßo do petr√≥leo
fig.add_trace(go.Scatter(
    x=df_brent.index,
    y=df_brent['petrol_price'],
    mode='lines',
    name='Pre√ßo Brent (USD)',
    line=dict(color='#1f77b4', width=2)
))

fig.update_layout(
    title="üìâ Evolu√ß√£o dos Pre√ßos do Petr√≥leo Brent",
    xaxis=dict(type='date'),
    xaxis_title="Data",
    yaxis_title="Pre√ßo (USD)",
    template="plotly_white",
    legend=dict(x=0, y=1),
    hovermode="x unified",
    height=600
)

"""Podemos ver que o pre√ßo teve longos per√≠odos de altas e baixas. Provavelmente devido aos eventos econ√¥micos e geopol√≠ticos que houveram. Portanto, para realizar a predi√ß√£o, iremos usar os √∫ltimos 5 anos (2020/01 - presente) para evitar enviesar o modelo com essas oscila√ß√µes at√≠picas do passado

### Modelagem com prophet
"""

df_brent['Close'].reset_index()

df_prophet = df = df_brent['Close'].reset_index().rename(columns={'BZ=F': 'petrol_price'}) #df_brent.copy()
#df_prophet.reset_index(inplace=True)
df_prophet.columns = ['ds', 'y']

df_prophet = df_prophet.query("ds >= '2020-01-01' ")

m = Prophet()
m.fit(df_prophet)
future = m.make_future_dataframe(periods=30)
forecast = m.predict(future)

forecast[['ds', 'yhat', 'yhat_lower', 'yhat_upper']].tail()

fig2 = plot_plotly(m, forecast)
fig2.update_layout(title='Previs√£o de Pre√ßo do Petroleo Brent com o modelo Prophet')
fig2.update_xaxes(title_text='Data')
fig2.update_yaxes(title_text='Pre√ßo do Petroleo Brent')
fig2.show()

plot_components_plotly(m, forecast)

df_cv = cross_validation(m, initial='730 days', period='180 days', horizon = '30 days')
# horizon: Period to be predicted.
# period -> Simulated forecast will be done at every this period. If not provided, 0.5 * horizon is used.
# initial: -> The first training period will include at least this much data.
df_p = performance_metrics(df_cv)

df_p.head()

df_p.tail()

# Adicionando eventos que impactaram o pre√ßo
events = pd.DataFrame([
    # Eventos hist√≥ricos relevantes
    {'holiday': 'crise_2020', 'ds': '2020-02-01', 'lower_window': 0, 'ds_upper': '2021-03-01'},
    {'holiday': 'crise_2022', 'ds': '2022-01-01', 'lower_window': 0, 'ds_upper': '2022-12-31'},

    # Eventos geopol√≠ticos e econ√¥micos recentes
    {'holiday': 'corte_producao_opec', 'ds': '2023-04-03', 'lower_window': 0, 'ds_upper': '2023-06-30'},
    {'holiday': 'guerra_russia_ucrania', 'ds': '2023-07-01', 'lower_window': 0, 'ds_upper': '2023-12-31'},
    {'holiday': 'conflito_oriente_medio', 'ds': '2024-01-01', 'lower_window': 0, 'ds_upper': '2024-03-31'},

    # Novos fatores externos relevantes
    {'holiday': 'pandemia_covid-19', 'ds': '2020-03-01', 'lower_window': 0, 'ds_upper': '2021-03-01'},
    {'holiday': 'choque_precos_gas', 'ds': '2021-10-01', 'lower_window': 0, 'ds_upper': '2022-03-01'},
    {'holiday': 'colapso_banco_silicon', 'ds': '2023-03-10', 'lower_window': 0, 'ds_upper': '2023-03-30'},
    {'holiday': 'redu√ß√£o_estoques_petroleo', 'ds': '2024-05-01', 'lower_window': 0, 'ds_upper': '2024-06-30'},
    {'holiday': 'san√ß√µes_russia', 'ds': '2024-06-01', 'lower_window': 0, 'ds_upper': '2024-12-31'}
])

for col in ['ds', 'ds_upper']:
  events[col] = pd.to_datetime(events[col])
events['upper_window'] = (events['ds_upper'] - events['ds']).dt.days
events

m2 = Prophet(holidays=events)
m2 = m2.fit(df_prophet)
future2 = m2.make_future_dataframe(periods=30)
forecast2 = m2.predict(future2)

forecast[['ds', 'yhat', 'yhat_lower', 'yhat_upper']].tail()

fig3 = plot_plotly(m2, forecast)
fig3.update_layout(title='Previs√£o de Pre√ßo do Petroleo Brent com o modelo Prophet')
fig3.update_xaxes(title_text='Data')
fig3.update_yaxes(title_text='Pre√ßo do Petroleo Brent')
fig3.show()

plot_components_plotly(m2, forecast)

df_cv2 = cross_validation(m2, initial='730 days', period='365 days', horizon = '30 days')
# horizon: Period to be predicted.
# period -> Simulated forecast will be done at every this period. If not provided, 0.5 * horizon is used.
# initial: -> The first training period will include at least this much data.
df_p2 = performance_metrics(df_cv2)

df_p2.tail()

"""### Modelo Arima"""

df_arima = df_prophet.copy()
df_arima = df_arima.set_index('ds')

df_arima.iloc[[0, -1]]

daily_data = df_arima['y'].resample('D').mean().interpolate(method='time')
result = seasonal_decompose(daily_data, model='multiplicative', period=365)
fig = result.plot()
fig.set_size_inches(14, 10)

# ADF test function
def adf_test(series):
    result = adfuller(series, autolag='AIC')
    return {'ADF_Statistic': result[0], 'p-value': result[1], 'Critical_Values': result[4]}

daily_adf_result = adf_test(daily_data)
print(f"ADF_Statistic: {daily_adf_result['ADF_Statistic']}")
print(f"p-value: {daily_adf_result['p-value']}")

print('Critical Values:')
for key, value in daily_adf_result['Critical_Values'].items():
    print('\t%s: %.3f' % (key, value))

"""p-value > 0.05, n√£o rejeitamos a hip√≥tese nula de que a s√©rie √© n√£o estacion√°ria."""

differenced_data = daily_data.diff().dropna()
differenced_adf_result = adf_test(differenced_data)

print(f"ADF_Statistic: {differenced_adf_result['ADF_Statistic']}")
print(f"p-value: {differenced_adf_result['p-value']}")

print('Critical Values:')
for key, value in differenced_adf_result['Critical_Values'].items():
    print('\t%s: %.3f' % (key, value))

"""Ap√≥s a diferencia√ß√£o, temos um p-value pr√≥ximo de zero, ent√£o podemos dizer que a s√©rie √© n√£o estacion√°ria, ou seja, a m√©dia e vari√¢ncia est√°veis ao longo do tempo"""

# Plotting the differenced Close price
plt.figure(figsize=(14, 7))
plt.plot(differenced_data.index, differenced_data, label='Diferen√ßa Pre√ßo Petr√≥leo Brent', color='orange')
plt.title('Diferen√ßa no Pre√ßo do Petr√≥leo Brent')
plt.xlabel('Date')
plt.ylabel('Diferen√ßa Petr√≥leo Brent')
plt.legend()
plt.show()

fig, axes = plt.subplots(1, 2, figsize=(16, 4))

plot_acf(differenced_data, lags=40, ax=axes[0])
axes[0].set_title('Autocorrelation Function (ACF)')

plot_pacf(differenced_data, lags=40, ax=axes[1])
axes[1].set_title('Partial Autocorrelation Function (PACF)')

plt.tight_layout()
plt.show()

"""Com base nesses gr√°ficos, podemos ver que o ACF corta a linha pontilhada azul na lag 1, enquanto o PACF corta a linha pontilhada azul na lag 1. Isso sugere que um modelo ARIMA(1,1,1) pode ser adequado para a s√©rie temporal j√° que fizemos 1 diferencia√ß√£o."""

def find_best_arima_model(time_series, p_range=range(0, 4), d_range=range(0, 3), q_range=range(0, 4)):
  best_aic = np.inf
  best_order = None
  best_model = None

  print("Searching best ARIMA(p,d,q)...")

  for p in p_range:
    for d in d_range:
      for q in q_range:
        try:
            with warnings.catch_warnings():
              warnings.filterwarnings("ignore")
              model = ARIMA(time_series, order=(p, d, q))
              model_fit = model.fit()
              aic = model_fit.aic
              #print(f"ARIMA({p},{d},{q}) AIC: {aic:.2f}")
              if aic < best_aic:
                best_aic = aic
                best_order = (p, d, q)
                best_model = model_fit
        except:
          continue

  print(f"\n‚úÖ Best ARIMA order: {best_order} with AIC: {best_aic:.2f}")
  return best_order, best_model

best_order, best_model = find_best_arima_model(daily_data)

print(best_model.summary())

# Modelagem com ARIMA
closing_prices = df_arima['y'].sort_index()
train_data = closing_prices[:'2023-12-31']
test_periods = pd.date_range('2024-01-01', periods=365, freq='B')

model_arima = ARIMA(train_data, order=(3,1,2))
model_fit = model_arima.fit()

forecast_arima = model_fit.get_forecast(steps=len(test_periods))
forecast_values = forecast_arima.predicted_mean
forecast_values_lower = forecast_arima.conf_int(alpha=0.05).iloc[:, 0]
forecast_values_upper = forecast_arima.conf_int(alpha=0.05).iloc[:, 1]

df_forecast = pd.DataFrame({
    'Data': test_periods,
    'Previs√£o': forecast_values,
    'Intervalo Inferior': forecast_values_lower,
    'Intervalo Superior': forecast_values_upper
})

fig = go.Figure()

# S√©rie hist√≥rica de treino
fig.add_trace(go.Scatter(
    x=train_data.index, y=train_data,
    mode='lines',
    name='Dados Treinamento',
    line=dict(color='blue')
))

# S√©rie de teste
fig.add_trace(go.Scatter(
    x=closing_prices['2023-12-31':].index,
    y=closing_prices['2023-12-31':],
    mode='lines',
    name='Dados de Teste',
    line=dict(color='green')
))

# Previs√£o central
fig.add_trace(go.Scatter(
    x=df_forecast['Data'], y=df_forecast['Previs√£o'],
    mode='lines',
    name='Previs√£o',
    line=dict(color='orange')
))

# Faixa de confian√ßa (√°rea sombreada)
fig.add_trace(go.Scatter(
    x=pd.concat([df_forecast['Data'], df_forecast['Data'][::-1]]),
    y=pd.concat([df_forecast['Intervalo Superior'], df_forecast['Intervalo Inferior'][::-1]]),
    fill='toself',
    fillcolor='rgba(255,165,0,0.2)',  # Laranja com transpar√™ncia
    line=dict(color='rgba(255,255,255,0)'),
    hoverinfo="skip",
    showlegend=True,
    name='Intervalo de Confian√ßa'
))

# Layout final
fig.update_layout(
    title="Previs√£o do Pre√ßo do Petr√≥leo Brent com ARIMA",
    xaxis_title="Data",
    yaxis_title="Pre√ßo do Petr√≥leo Brent",
    legend=dict(x=0, y=1),
    hovermode='x unified',
    template='plotly_white',
    height=600
)

print(f"AIC: {model_fit.aic}")
print(f"BIC: {model_fit.bic}")

forecast_ar = forecast_values[:len(closing_prices['2024-01-02':])]
test_close = closing_prices['2024-01-02':]

# Calculate RMSE
rmse = np.sqrt(mean_squared_error(test_close, forecast_ar))
print(f"RMSE: {rmse:.4f}")

joblib.dump(model_fit, 'arima_model.pkl')

joblib.dump(m, 'prophet_model_v2.pkl')